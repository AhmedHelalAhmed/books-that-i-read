- Microservices is an architecture choice.
- Microservices are independently releasable services.
- Each service encapsulate functionality and make it accessible to other services via network.
- Microservises can use different technologies.
- Each service treated as a black box.
- Each service hosts business functionality on one or more endpoints.
- Each service hide the technology and encapsulates its own database.
- Microservices avoid the use of shared databases.
- Microservices support the concepts of information hiding.
- Each service don't change in backward-incompatible fashion.
- Microservices works on isolation and releasable on demand.
- Microservices comes to provide loosely coupled services.
- SOA: service oriented architecture in it some of services cooperates to build the system but everything coupled to a database and had to deploy everything together.
- Microservices means independent deployability.
- Microservices requires loosely coupled services.
- Microservices requires explicit well-defined and stable contracts between services.
- Model services around business domains.
- Services must be end-to-end slices of business logic and data.
- Size: the goal of microservices is to have as small an interface as possible.
- more services means the complexity of the system will be more.
- Flexibility: the architecture should help us to solve the problems we might face in the future.
- Microservices is an alternative to monolithic architecture.
- Monoliths means unit of deployment when all functionality in a system must be deployed together.
- A classic single-process monolithic deployment can make sense for many small organizations.
- When monolithic grow it brings modular monolith.
- Modular monolith: a single process consists of separate modules each module can be worked independently but all need to be combined together for deployment
- Modular monolith example is Shopify
- Modular monolith with a decomposed database
- A distributed monolith is a system that consists of multiple services and the entire system must be deployed together.
- A distributed monolith has all disadvantages of a distributed system and single-process monolith.
- A distributed monolith is highly coupled architecture.
- Delivery contention a different developers wanting to change the same piece of code and wanting to push functionality live at different times 
- Microservice architecture give you more concrete boundaries and more flexibility
- Advantages of monoliths: 
  - Much simpler in deployment
  - Simpler developer workflows, monitoring and troubleshooting
- Advantages of microservice:
  - Enabling technology
  - Log aggregation and distributed tracing (Lightstep- Honeycomb)
  - Containers and Kubernetes Managing containers across machines
  - Streaming (Apache Kafka) share data between microservices
  - public cloud and serverless (Google cloud - Amazon web services - microsoft Azure) => database instance - kubernetes cluster - broker - distributed filesystems
  - Robustness 
    In a monolithic service if the service fails everything stops working 
    with a monolithic system we can run on multiple machines to reduce our chance of failure but with microservices we can build systems that handle the total failure of some constituent services and degrade functionality accordingly
  - Scaling: 
    In monolithic service we need to scale everything together but in microservices we can scale just the service we need
    this will control the costs effectively
  - Ease of deployment:
    high risk deployment as we deploy million to release the change.
  - Organizational Alignment: smaller teams working on smaller codebases tends to be more productive
  - Composability: reuse of functionality - allowed to consume functionality in different ways and purposes
- Microservice pain points:
 - Complexity
 - Developer experience the limit in the local machine (develop in the cloud) - limit the scope
 - Technology overload 
 - Cost: parallel functionalities to get more customers it will not reduce the cost
 - Reporting: difficult as the data scattered across multiple isolated schemas.
 - Monitoring and troubleshooting
 - Security: a lot of information flows over the networks between services.
 - Testing: run tests across multiple processes all of which need to be deployed and appropriately configured for test scenarios
 - Latency
 - Data consistency: multiple processes manage state in different databases in monolith we can rely on database transactions to manage the state changes

- Microservices not for small teams or start ups and you have to pay microservice tax 
- Microservices give you huge flexibility but you have to pay the cost and face complexity 
## chapter2 
- What makes a good microservice boundary? 
- ability to change one service in isolation is the main point
- information hiding means hide a lot of details behind microservice that allow us to develop independently and make the work done in parallel which improve development time
- comprehensibility make understand of each microservice in isolation which helps to understand the whole system
- Flexibility: where a change in functionality of the system in microservice is independently in addition combine the microservices in different way deliver new functionality
- Cohesion: the code that changes together stay together
- we want to group functionalities in such a way we can make changes in as a few places as possible
- we want to sit related behavior together and unrelated behavior to sit elsewhere 
- we want to change in one place because changing in different places is slower and risky
- we say cohesion is weak if the related functionality spread across the system and microservice aiming for strong cohesion
- loosely coupled service a change to one service should not required a change to an other service.
- domain coupling: one microservice needs another microservice because it has the functionality it provide
- pass through coupling: one microservice passes data to another microservice because the data is needed by some other microservice further downstream
- pass through can be solved by make service call the required data service directly which cause domain coupling or ignore the format of the data and treat it like a blob 
- common coupling: when two or more microservice make a use of a common set of data example shared database, shared memory or shared filesystem
- content coupling: when upstream service reached into the internals of a downstream service and change its internal state 
- when external service accessing another microservice's database and change it directly
- content coupling in it the lines of ownership become less clear and more difficult for developers to change a system.

- we can find microservice boundaries around the domain 
- ubiquitous language: define a common language to be used in code and describing the domain to aid communication
- aggregate: a collection of objects that are managed as a single entity 
- bonded context: an explicit boundary within a business domain that provides functionality to wider system but that also hide complexity
- ubiquitous language: use the same terms in our code as the users use that make it easier to model the real-world domain and also improve communication
- Aggregate: a representation of a real domain concept that has a life cycle and can be implemented as a state machine
- we want to group the code that handle the state transition of an aggregate together
- one aggregate should manage by one microservice
- if an outside party requests a state transition in an aggregate can say no as you want to implement your aggregate in such way that illegal state transitions are impossible
- relationship between aggregates can be represented as foreign key or store as customers/1 or soundcloud:tracks:123 
- bounded context a large organizational boundary within the scope and explicit responsibilities
- bounded context contains one or more aggregates some aggregates may be exposed outside the bounded context others may be hidden internally 
- aggregate is a self-contained state machine that focuses on a single domain concept in our system
- bounded context a collection of associated aggregates with explicit interface to the wider world 
- one microservice can manage one or more aggregates but we don't want one aggregate to be managed by more than one microservice
- event storming: a collaborative brainstorming exercise designed to help surface a domain model
- Advantages of DDD: information hiding that helps in stable 
- Volatility: by identify parts of the system going through more frequent change and extract that functionality into their own service
- Data: the nature of the data you hold and manage can drive you toward different forms of decomposition 
- Technology: the need to make use of different technology.
- Organizational: we considering organizational structure to support architecture
## chapter3
- microservices are not the goal 
- you must have a clear understanding of what you expect to achieve 
- migration should be incremental
- Make a change, roll that change out, assess it, and go again. Even the act of splitting out one microservice can itself be broken down into a series of small steps
- you should be thinking of migrating to a microservice architecture only if you can't find any easier way to move toward your end goal with you current architecture 
- scale your system can be done by spinning up a few copies of your existing monolithic system behind a load balancer may well help you scale your system much more effectively than going through a complex and lengthy decomposition to microservices
- microservices aren't easy. try the simple stuff first
- if you do a big-bang rewrite, the only thing you're guaranteed of is a big bang
- break the big journey into lots of little steps
- breaking things into smaller pieces also allows you to identify quick wins and learn from them
- focus on the benefits you expect your change in architecture to bring
- It's common for the existing monolithic architecture to remain after a shift toward microservices 
- we can move 10% of functionality that is currently bottleneck leaving the remaining 90% in the monolithic system
- by making your migration to microservices an incremental journey you are able to chip a way at the existing monolithic architecture delivering improvements along the way, while also importantly knowing when to stop
- what to split first?!
- you need to prioritize which microservice to create first 
- you want to scale the application 
- the functionality that currently constrains the system's ability to handle load is going to be high priority
- if you want to improve time to market look at the system's volatility to identify those pieces of functionality that change most frequently and see if they would work as microservices
- CodeScene is analysis tools to helps to identify volatile parts of codebase 
- we have to consider what decompositions are viable
- some functionality impossible to detangled 
- the functionality you want to migrate might already somewhat self-contained and so the extraction seems very straightforward
- the decision about decomposition occur based on: 
  - how easy the extraction is?
  - what is the benefit of extracting?
- start with easy small part as you need some momentum early
- if you try to extract what you consider to be the easiest microservice and aren't able to make it work it might be worth reconsidering
- with a few successes and some lessons learned you 'll be much better placed to tackle more complex extractions
- decomposition by layer: 
  - code first
  - data first
- we can decompose UI and backend along with storage 
- code first tends to be the most common first step
- code first tends to deliver short-term benefit 
- if we left the data in the monolithic database the we are storing up lots of pain for the future 
- we have gained a lot from our new microservice
- if we found that it was impossible to extract the application code we could abort
- if the application code extracted but the data proves to be impossible we could be in trouble
- we need to be sure if we go with code first the data can be decomposed so the extraction is viable
- if you unsure whether the data can be separated then use data first
- the benefit of data first is in derisking the full extraction of the microservice 
- data first forces you to deal up front with issues like loss of enforced data integrity in you database or lack of transactional operations across both sets of data
- strangler fig pattern: 
  - frequent use during system rewrites 
  - describes the process of wrapping an old system with the new system over time allowing the new system to take over more and more features of the old system incrementally
  - you intercept calls to the existing system if the call to that piece of functionality is implemented in our new microservice architecture it is redirected to the microservice and if the functionality is still provided by the monolith the call is allowed to continue to the monolith itself
  - the benefit is that is can be done without making any change to the underlying monolithic application which is unaware that it has even been wrapped with a newer system
- parallel run: 
  - when the functionality which migrated is critical to your organization 
  - one way to make sure the new functionality is working well without risking the existing system 
  - running both monolithic implementation and microservice implementation side by side serving the same requests and comparing the result
- feature toggle:
  - is a mechanism that allows a feature to be switched off or on 
  - to switch between two different implementations of some functionality
  - it is useful as part of a microservice migration
  - we can implement the feature toggle in proxy layer to allow for a simple control to switch between implementations
- data decomposition concerns: issues happens when breaking databases apart
  - performance
  - data integrity
  - transactions
  - tooling
  - reporting database
- performance
  - we move join operations from the data tier into the microservices and this may be slow down 
  - the join gone from the data tier to the application code tier
  - we could aggressively cached - look up in bulk - caching information locally
  - latency (the response time) maybe increase
- data integrity
  - the tables living in different databases 
  - tables no longer have enforcement of the integrity of data model
  - you can no longer rely on your database to enforce the integrity of inter-entity relationships
  - there are workarounds for example coping patterns but we have to resolve how we wanted to handle synchronizing changes
  - use soft delete 
- transactions
  - we lose the safety of the transactions
  - use Sagas as alternative mechanisms to distributed transactions for managing state changes across multiple microservices this will ass complexity
- Tooling
  - there are many tools help us manage the process of changing the schema of a relational database
  - each schema change is defined in a version-controlled delta script which run in strict order 
  - some tools like Flyway or Liquibase 
- reporting database
  - we break database to hide access to internal data storage 
  - by hiding direct access to our database we are able to create stable interfaces 
  - so accessing the data become from REST API 
  - we create dedicated database that designed for external access 
  - it responsible to push data from internal storage to the external access
  - allows us to hide internal state management while still presenting the data in a database
  - we should expose only the minimum data 
  - treat like a microservice